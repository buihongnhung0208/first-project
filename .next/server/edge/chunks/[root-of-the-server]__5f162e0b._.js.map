{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/auth.ts"],"sourcesContent":["import { compareSync } from 'bcrypt-ts-edge';\nimport type { NextAuthConfig } from 'next-auth';\nimport NextAuth from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\n\nimport { prisma } from '@/db/prisma';\nimport { PrismaAdapter } from '@auth/prisma-adapter';\n\nexport const config = {\n  secret: process.env.NEXTAUTH_SECRET || \"fallback-secret-key-for-development\",\n  pages: {\n    signIn: '/sign-in',\n    error: '/sign-in',\n  },\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60, // 30 days\n  },\n  providers: [\n    CredentialsProvider({\n      credentials: {\n        email: {\n          type: 'email',\n        },\n        password: { type: 'password' },\n      },\n      async authorize(credentials) {\n        if (credentials == null) return null;\n\n        // Find user in database\n        const user = await prisma.user.findFirst({\n          where: {\n            email: credentials.email as string,\n          },\n        });\n        // Check if user exists and password is correct\n        if (user && user.password) {\n          const isMatch = compareSync(\n            credentials.password as string,\n            user.password\n          );\n          // If password is correct, return user object\n          if (isMatch) {\n            return {\n              id: user.id,\n              name: user.name,\n              email: user.email,\n              role: user.role,\n            };\n          }\n        }\n        // If user doesn't exist or password is incorrect, return null\n        return null;\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user, trigger, session }: any) {\n      // Assign user fields to token\n      if (user) {\n        token.id = user.id;\n        token.role = user.role;\n\n        // If user has no name, use email as their default name\n        if (user.name === 'NO_NAME') {\n          token.name = user.email!.split('@')[0];\n\n          // Update the user in the database with the new name\n          await prisma.user.update({\n            where: { id: user.id },\n            data: { name: token.name },\n          });\n        }\n      }\n\n      // Handle session updates (e.g., name change)\n      if (session?.user.name && trigger === 'update') {\n        token.name = session.user.name;\n      }\n\n      return token;\n    },\n    async session({ session, user, trigger, token }: any) {\n      // Map the token data to the session object\n      session.user.id = token.id || token.sub;\n      session.user.name = token.name;\n      session.user.role = token.role;\n\n      // Optionally handle session updates (like name change)\n      if (trigger === 'update' && token.name) {\n        session.user.name = token.name;\n      }\n\n      // Return the updated session object\n      return session;\n    },\n  },\n} satisfies NextAuthConfig;\n\nexport const { handlers, auth, signIn, signOut } = NextAuth(config);\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAEA;AACA;AAAA;AAEA;;;;;AAGO,MAAM,SAAS;IACpB,QAAQ,QAAQ,GAAG,CAAC,eAAe,IAAI;IACvC,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IACA,SAAS;QACP,UAAU;QACV,QAAQ,KAAK,KAAK,KAAK;IACzB;IACA,WAAW;QACT,IAAA,6MAAmB,EAAC;YAClB,aAAa;gBACX,OAAO;oBACL,MAAM;gBACR;gBACA,UAAU;oBAAE,MAAM;gBAAW;YAC/B;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,eAAe,MAAM,OAAO;gBAEhC,wBAAwB;gBACxB,MAAM,OAAO,MAAM,8HAAM,CAAC,IAAI,CAAC,SAAS,CAAC;oBACvC,OAAO;wBACL,OAAO,YAAY,KAAK;oBAC1B;gBACF;gBACA,+CAA+C;gBAC/C,IAAI,QAAQ,KAAK,QAAQ,EAAE;oBACzB,MAAM,UAAU,IAAA,+KAAW,EACzB,YAAY,QAAQ,EACpB,KAAK,QAAQ;oBAEf,6CAA6C;oBAC7C,IAAI,SAAS;wBACX,OAAO;4BACL,IAAI,KAAK,EAAE;4BACX,MAAM,KAAK,IAAI;4BACf,OAAO,KAAK,KAAK;4BACjB,MAAM,KAAK,IAAI;wBACjB;oBACF;gBACF;gBACA,8DAA8D;gBAC9D,OAAO;YACT;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAO;YAC9C,8BAA8B;YAC9B,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;gBAEtB,uDAAuD;gBACvD,IAAI,KAAK,IAAI,KAAK,WAAW;oBAC3B,MAAM,IAAI,GAAG,KAAK,KAAK,CAAE,KAAK,CAAC,IAAI,CAAC,EAAE;oBAEtC,oDAAoD;oBACpD,MAAM,8HAAM,CAAC,IAAI,CAAC,MAAM,CAAC;wBACvB,OAAO;4BAAE,IAAI,KAAK,EAAE;wBAAC;wBACrB,MAAM;4BAAE,MAAM,MAAM,IAAI;wBAAC;oBAC3B;gBACF;YACF;YAEA,6CAA6C;YAC7C,IAAI,SAAS,KAAK,QAAQ,YAAY,UAAU;gBAC9C,MAAM,IAAI,GAAG,QAAQ,IAAI,CAAC,IAAI;YAChC;YAEA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAO;YAClD,2CAA2C;YAC3C,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE,IAAI,MAAM,GAAG;YACvC,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAC9B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAE9B,uDAAuD;YACvD,IAAI,YAAY,YAAY,MAAM,IAAI,EAAE;gBACtC,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YAEA,oCAAoC;YACpC,OAAO;QACT;IACF;AACF;AAEO,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAA,wKAAQ,EAAC"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["export { auth as middleware } from '@/auth';\n\n"],"names":[],"mappings":";AAAA"}}]
}